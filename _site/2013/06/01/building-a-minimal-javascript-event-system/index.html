<!DOCTYPE html>
<html>
  <head>
    <title>Building a minimal JavaScript event system :: Joe Corcoran</title>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="author" content="Joe Corcoran">
<script type="text/javascript" src="//use.typekit.net/lbi3uvk.js"></script>
<script type="text/javascript">try{Typekit.load();}catch(e){}</script>

<link rel="stylesheet" href="/public/main.min.css" type="text/css" />
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-3245696-4']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
  </head>
  <body>
    <header role="banner" class="banner">
  <div class="banner-content">
    <h1><a href="/">Joe Corcoran</a></h1>
    <nav>
      <ul>
        <li><a href="/" class="active">Blog</a></li>
        <li><a href="/about" >About</a></li>
        <li><a href="/projects" >Projects</a></li>
      </ul>
    </nav>
  </div>
</header>
    <article class="post">
      <header>
        <h1>Building a minimal JavaScript event system</h1>
        <time datetime="2013-06-01T00:00:00+01:00">01 June 2013</time>
        

  <ul class="tags">
    
      <li>
        <a href="/tags/javascript">javascript</a>
      </li>
    
      <li>
        <a href="/tags/events">events</a>
      </li>
    
      <li>
        <a href="/tags/tutorial">tutorial</a>
      </li>
    
  </ul>


      </header>
      <p><em>This article is intended to encourage front-end developers to design and build software thoughtfully. The content assumes a basic knowledge of JavaScript and comfort running simple commands like <code>cd</code> at the command line. I hope the test examples in this article are straightforward, but if you&rsquo;re not familiar with writing tests first, or even testing your code at all, you might want to <a href="http://en.wikipedia.org/wiki/Test-driven_development">read a little about it first</a>. The general idea is that we make an assertion about how our code should behave in the form of a test. We then write some code, run the test and repeat this loop until the test passes.</em></p>

<h2>Events</h2>

<p>Events are integral to programming on the web. They allow us to declare an interest in a specific happening in our system (user input from the keyboard, for example) and respond to it. These kinds of interactions are <em>asynchronous</em>; we don&rsquo;t know when an event will happen, so we write code that can respond whenever it does.</p>

<p>Programming with events involves two parts. The first part is <em>listening</em>. We specify that we want to call a particular function when a named event happens. This is often referred to as <em>binding</em>; we <em>bind</em> that function to the event. The second part is <em>announcing</em>, meaning actually making the event happen. This is commonly referred to as <em>triggering</em> or <em>firing</em> an event.</p>

<p>You can find examples of this code pattern in <a href="https://developer.mozilla.org/en-US/docs/Web/API/Event">the DOM</a> and in popular libraries like <a href="http://api.jquery.com/category/events/event-object/">jQuery</a> and <a href="http://backbonejs.org/#Events">Backbone.js</a>.</p>

<h2>The task</h2>

<p>We will create an object capable of announcing and listening for events and a function for mixing that capability into any other object. We&rsquo;re not talking about the DOM events that occur when a user clicks a link or focuses on an input but a separate, custom event system. We&rsquo;ll end up with something quite similar to <a href="http://backbonejs.org/#Events">the <code>Events</code> object from Backbone.js</a> but with fewer features.</p>

<p>We&rsquo;ll use the JavaScript testing framework Jasmine to describe our event behaviour first. Then we&rsquo;ll write the code to match our description. <a href="http://github.com/joecorcoran/event-tutorial">A template for this exercise is available on GitHub</a>, to help you get started without setting up the test environment. If you&rsquo;re comfortable with <a href="http://git-scm.com/">Git</a>, it would be a good idea to fork this repo and <code>git clone</code> your forked copy. If not, don&rsquo;t worry, you can just <a href="https://github.com/joecorcoran/event-tutorial/archive/master.zip">download the template (ZIP)</a>. You will need to have <a href="http://nodejs.org/download/">Node.js</a> installed to run the tests.</p>

<p>Let&rsquo;s start with an object that contains two functions, <code>on</code> and <code>trigger</code>. We have chosen these names by loose convention; we hope they will be recognised by programmers who have worked with events before.</p>

<p>We&rsquo;ll use the <code>on</code> function to instruct our object to listen for specific events. So <code>object.on(&#39;foo&#39;, callback)</code>, will mean <em>on hearing the <code>&#39;foo&#39;</code> event happen, call the <code>callback</code> function</em>. </p>

<p>We&rsquo;ll use the <code>trigger</code> function to make events happen. So <code>object.trigger(&#39;foo&#39;, data)</code> will mean <em>tell <code>object</code> that the <code>&#39;foo&#39;</code> event has happened and to pass <code>data</code> to the callback function</em>.</p>
<div class="highlight"><pre><code class="javascript language-javascript" data-lang="javascript"><span class="c1">// evented-spec.js</span>
<span class="nx">describe</span><span class="p">(</span><span class="s1">&#39;Evented&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">describe</span><span class="p">(</span><span class="s1">&#39;Event&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">eventObj</span> <span class="o">=</span> <span class="nx">Evented</span><span class="p">.</span><span class="nx">Event</span><span class="p">;</span>
    <span class="nx">it</span><span class="p">(</span><span class="s1">&#39;has on function&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
      <span class="nx">expect</span><span class="p">(</span><span class="nx">eventObj</span><span class="p">.</span><span class="nx">on</span><span class="p">).</span><span class="nx">toEqual</span><span class="p">(</span><span class="nx">jasmine</span><span class="p">.</span><span class="nx">any</span><span class="p">(</span><span class="nb">Function</span><span class="p">));</span>
    <span class="p">});</span>
    <span class="nx">it</span><span class="p">(</span><span class="s1">&#39;has trigger function&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
      <span class="nx">expect</span><span class="p">(</span><span class="nx">eventObj</span><span class="p">.</span><span class="nx">trigger</span><span class="p">).</span><span class="nx">toEqual</span><span class="p">(</span><span class="nx">jasmine</span><span class="p">.</span><span class="nx">any</span><span class="p">(</span><span class="nb">Function</span><span class="p">));</span>
    <span class="p">});</span>
  <span class="p">});</span>
<span class="p">});</span>
</code></pre></div>
<p><code>jasmine.any</code> is a utility that lets us make assertions about an object&rsquo;s type. We&rsquo;re starting out by simply specifying that our object must have two properties named <code>on</code> and <code>trigger</code> and they both must hold functions.</p>

<p>Let&rsquo;s run the tests.</p>

<p><em>Whenever you see a block of monospaced text that looks like the one below, it&rsquo;s the test output; the way in which Jasmine tells us whether our tests have passed or failed.</em></p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">FF

Failures:

  1) Evented Event has on function
   Message:
     Expected undefined to equal &lt;jasmine.any(function Function() { [native code] })&gt;.

Finished in 0.007 seconds
2 tests, 2 assertions, 2 failures
</code></pre></div>
<p>Okay, the tests fail as expected. We haven&rsquo;t written any code yet! We can fix that.</p>
<div class="highlight"><pre><code class="javascript language-javascript" data-lang="javascript"><span class="c1">// evented.js</span>
<span class="kd">var</span> <span class="nx">Evented</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">Event</span><span class="o">:</span> <span class="p">{</span>
    <span class="nx">on</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{},</span>
    <span class="nx">trigger</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{}</span>
  <span class="p">}</span>
<span class="p">};</span>
</code></pre></div><div class="highlight"><pre><code class="text language-text" data-lang="text">..

Finished in 0.007 seconds
2 tests, 2 assertions, 0 failures
</code></pre></div>
<p>Okay, our tests pass! Now let&rsquo;s write some meaningful behaviour. We have an interesting situation here in that the two functions we need to write are useless without each other. Ideally we would test the behaviour of each function in isolation (<a href="http://alistapart.com/article/writing-testable-javascript">read more about why this is a good idea</a>). However, in this case it isn&rsquo;t really helpful to describe the behaviour of one function without the other. At a minimum, we want to know that we can tell our object to listen for an event and then respond when that event is triggered. So let&rsquo;s think about what that would look like in code.</p>
<div class="highlight"><pre><code class="javascript language-javascript" data-lang="javascript"><span class="c1">// evented-spec.js</span>
<span class="nx">describe</span><span class="p">(</span><span class="s1">&#39;Event&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// ...</span>
  <span class="nx">it</span><span class="p">(</span><span class="s1">&#39;executes callback when event is triggered&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">callback</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{};</span>
    <span class="nx">eventObj</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="nx">callback</span><span class="p">);</span>
    <span class="nx">eventObj</span><span class="p">.</span><span class="nx">trigger</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">);</span>
  <span class="p">});</span>
<span class="p">});</span>
</code></pre></div>
<p>We expect that when the <code>&#39;foo&#39;</code> event is triggered, our <code>callback</code> function should have been called. But how do we actually test this? JavaScript doesn&rsquo;t provide a way to check whether or not a function was called. To achieve this, we need a <em>spy</em>. A spy is an object that we can use in place of a function. We can then ask the spy questions like &ldquo;were you called?&rdquo;, &ldquo;how many times were you called?&rdquo; and &ldquo;when you were called, what arguments did you receive?&rdquo;. So let&rsquo;s update our spec.</p>
<div class="highlight"><pre><code class="javascript language-javascript" data-lang="javascript"><span class="c1">// evented-spec.js</span>
<span class="nx">describe</span><span class="p">(</span><span class="s1">&#39;Event&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// ...</span>
  <span class="nx">it</span><span class="p">(</span><span class="s1">&#39;executes callback when event is triggered&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">callback</span> <span class="o">=</span> <span class="nx">jasmine</span><span class="p">.</span><span class="nx">createSpy</span><span class="p">();</span>
    <span class="nx">eventObj</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="nx">callback</span><span class="p">);</span>
    <span class="nx">eventObj</span><span class="p">.</span><span class="nx">trigger</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">);</span>
    <span class="nx">expect</span><span class="p">(</span><span class="nx">callback</span><span class="p">).</span><span class="nx">toHaveBeenCalled</span><span class="p">();</span>
  <span class="p">});</span>
<span class="p">});</span>
</code></pre></div><div class="highlight"><pre><code class="text language-text" data-lang="text">..F

Failures:

  1) Evented Event executes callback with correct arguments when event is triggered
   Message:
     Expected spy unknown to have been called.

Finished in 0.009 seconds
3 tests, 3 assertions, 1 failure
</code></pre></div>
<p>Okay, we already knew that would fail. So now we can try our hands at the implementation. Firstly, the <code>on</code> function needs to store event names and their list of corresponding callback functions. JavaScript doesn&rsquo;t have <a href="http://en.wikipedia.org/wiki/Hash_table">hashes (sometimes called dictionaries)</a> so, for better or worse, it&rsquo;s common to use objects for this purpose.</p>
<div class="highlight"><pre><code class="javascript language-javascript" data-lang="javascript"><span class="c1">// evented.js</span>
<span class="kd">var</span> <span class="nx">Evented</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">Event</span><span class="o">:</span> <span class="p">{</span>
    <span class="nx">on</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">event</span><span class="p">,</span> <span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">events</span> <span class="o">=</span> <span class="p">{};</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">events</span><span class="p">[</span><span class="nx">event</span><span class="p">]</span> <span class="o">=</span> <span class="p">[];</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">events</span><span class="p">[</span><span class="nx">event</span><span class="p">].</span><span class="nx">push</span><span class="p">(</span><span class="nx">callback</span><span class="p">);</span>
    <span class="p">},</span>
    <span class="nx">trigger</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{}</span>
  <span class="p">}</span>
<span class="p">};</span>
</code></pre></div>
<p>Not a terrible start, but one problem sticks out. We can only store one event-callback pair at a time, as each time we call <code>on</code> we will reset the <code>events</code> object. We need to test for the existence of the <code>events</code> property before we can confidently assign the empty object.</p>
<div class="highlight"><pre><code class="javascript language-javascript" data-lang="javascript"><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="k">this</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="s1">&#39;events&#39;</span><span class="p">))</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">events</span> <span class="o">=</span> <span class="p">{};</span>
<span class="p">}</span>
</code></pre></div>
<p>We have the same problem on the next line too. We&rsquo;re resetting <code>this.events[event]</code> to an empty array even if it already exists. So let&rsquo;s improve that.</p>
<div class="highlight"><pre><code class="javascript language-javascript" data-lang="javascript"><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="k">this</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="s1">&#39;events&#39;</span><span class="p">))</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">events</span> <span class="o">=</span> <span class="p">{};</span>
<span class="p">}</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="k">this</span><span class="p">.</span><span class="nx">events</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="nx">event</span><span class="p">))</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">events</span><span class="p">[</span><span class="nx">event</span><span class="p">]</span> <span class="o">=</span> <span class="p">[];</span>
<span class="p">}</span>
</code></pre></div>
<p>These necessary checks are in place. There&rsquo;s nothing wrong with this code as it is, but we can make a further improvement using what is known as <a href="http://en.wikipedia.org/wiki/Short-circuit_evaluation">short-circuit evaluation</a>.</p>
<div class="highlight"><pre><code class="javascript language-javascript" data-lang="javascript"><span class="k">this</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="s1">&#39;events&#39;</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">events</span> <span class="o">=</span> <span class="p">{});</span>
<span class="k">this</span><span class="p">.</span><span class="nx">events</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">events</span><span class="p">[</span><span class="nx">event</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]);</span>
</code></pre></div>
<p>This takes advantage of the way in which the logical operator <code>||</code> works. Each expression is evaluated in turn from left to right. When one of the expressions is <em><a href="http://codepen.io/philipwalton/pen/nufrk">truthy</a></em>, it is returned and the other expressions are not evaluated. So if <code>this.hasOwnProperty(&#39;events&#39;)</code> returns <code>true</code>, the assignment on the right of the <code>||</code> operator simply doesn&rsquo;t happen.</p>

<p>So let&rsquo;s recap. The <code>on</code> function is looking good now.</p>
<div class="highlight"><pre><code class="javascript language-javascript" data-lang="javascript"><span class="c1">// evented.js</span>
<span class="kd">var</span> <span class="nx">Evented</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">Event</span><span class="o">:</span> <span class="p">{</span>
    <span class="nx">on</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">event</span><span class="p">,</span> <span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="s1">&#39;events&#39;</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">events</span> <span class="o">=</span> <span class="p">{});</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">events</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">events</span><span class="p">[</span><span class="nx">event</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]);</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">events</span><span class="p">[</span><span class="nx">event</span><span class="p">].</span><span class="nx">push</span><span class="p">(</span><span class="nx">callback</span><span class="p">);</span>
    <span class="p">},</span>
    <span class="nx">trigger</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{}</span>
  <span class="p">}</span>
<span class="p">};</span>
</code></pre></div>
<p>We can now implement <code>trigger</code> pretty easily.</p>
<div class="highlight"><pre><code class="javascript language-javascript" data-lang="javascript"><span class="c1">// evented.js</span>
<span class="kd">var</span> <span class="nx">Evented</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">Event</span><span class="o">:</span> <span class="p">{</span>
    <span class="nx">on</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">event</span><span class="p">,</span> <span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="s1">&#39;events&#39;</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">events</span> <span class="o">=</span> <span class="p">{});</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">events</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">events</span><span class="p">[</span><span class="nx">event</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]);</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">events</span><span class="p">[</span><span class="nx">event</span><span class="p">].</span><span class="nx">push</span><span class="p">(</span><span class="nx">callback</span><span class="p">);</span>
    <span class="p">},</span>
    <span class="nx">trigger</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">callbacks</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">events</span><span class="p">[</span><span class="nx">event</span><span class="p">];</span>
      <span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">l</span> <span class="o">=</span> <span class="nx">callbacks</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">l</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">callbacks</span><span class="p">[</span><span class="nx">i</span><span class="p">]();</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">};</span>
</code></pre></div><div class="highlight"><pre><code class="text language-text" data-lang="text">...

Finished in 0.007 seconds
3 tests, 3 assertions, 0 failures
</code></pre></div>
<p>Hooray, our tests all pass! The next thing to consider is that we need to be able to pass an arbitrary number of further arguments to <code>trigger</code> and have them passed onto the stored callback functions. Let&rsquo;s update our test.</p>
<div class="highlight"><pre><code class="javascript language-javascript" data-lang="javascript"><span class="c1">// evented-spec.js</span>
<span class="nx">describe</span><span class="p">(</span><span class="s1">&#39;Event&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// ...</span>
  <span class="nx">it</span><span class="p">(</span><span class="s1">&#39;executes callback with correct arguments when event is triggered&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">callback</span> <span class="o">=</span> <span class="nx">jasmine</span><span class="p">.</span><span class="nx">createSpy</span><span class="p">(</span><span class="s1">&#39;callback&#39;</span><span class="p">);</span>
    <span class="nx">eventObj</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="nx">callback</span><span class="p">);</span>
    <span class="nx">eventObj</span><span class="p">.</span><span class="nx">trigger</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
    <span class="nx">expect</span><span class="p">(</span><span class="nx">callback</span><span class="p">).</span><span class="nx">toHaveBeenCalledWith</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
  <span class="p">});</span>
<span class="p">});</span>
</code></pre></div><div class="highlight"><pre><code class="text language-text" data-lang="text">..F

Failures:

  1) Evented Event executes callback with correct arguments when event is triggered
   Message:
     Expected spy callback to have been called with [ 1, 2 ] but actual calls were [  ]

Finished in 0.012 seconds
</code></pre></div>
<p>We aren&rsquo;t passing the arguments on. So how can we access an arbitrary number of arguments? Usually when defining a function, we use named arguments as follows.</p>
<div class="highlight"><pre><code class="javascript language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">f</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">a</span><span class="p">;</span>
<span class="p">};</span>
<span class="nx">f</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// =&gt; 1</span>
</code></pre></div>
<p>But if we don&rsquo;t know how many arguments will be given, we can access them through the <code>arguments</code> object.</p>
<div class="highlight"><pre><code class="javascript language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">f</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">arguments</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">};</span>
<span class="nx">f</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span> <span class="c1">// =&gt; 2</span>
</code></pre></div>
<p>We&rsquo;ll need to grab all of the arguments passed to <code>trigger</code> apart from the first one, which is the string representing the name of the event. A list of items minus the first one is often referred to as the list&rsquo;s <em>tail</em>. A good way of getting the tail of an array is to use the <code>slice</code> function.</p>
<div class="highlight"><pre><code class="javascript language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">];</span>
<span class="nx">a</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// =&gt; [&#39;b&#39;, &#39;c&#39;]</span>
</code></pre></div>
<p>We pass the number <code>1</code> to <code>slice</code>, meaning <em>return all the items in the array, starting from index 1</em>. Since the indices of an array start at 0, this returns everything from the second item onwards. Sadly, even though the arguments object has many array-like properties, <a href="https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Functions_and_function_scope/arguments">it&rsquo;s not an array</a>. So we can&rsquo;t use <code>slice</code> in that way.</p>
<div class="highlight"><pre><code class="javascript language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">tail</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">arguments</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">};</span>
<span class="nx">tail</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">);</span> <span class="c1">// =&gt; TypeError: Object has no method &#39;slice&#39;</span>
</code></pre></div>
<p>Thankfully we can access the <code>slice</code> function in another, much uglier way. Here&rsquo;s how.</p>
<div class="highlight"><pre><code class="javascript language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">tail</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">slice</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">arguments</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">};</span>
<span class="nx">tail</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">);</span> <span class="c1">// =&gt; [&#39;b&#39;, &#39;c&#39;]</span>
</code></pre></div>
<p>What?! Well, it&rsquo;s not quite as complicated as it looks. Let&rsquo;s work through it piece by piece.</p>

<p><code>Array.prototype</code> is simply the object that holds all of the functions we are familiar with using on arrays, like <code>join</code>, <code>shift</code> and <code>slice</code>. If you&rsquo;re familiar with class-based programming languages, you can think of functions stored in the <code>prototype</code> object as roughly equivalent to <a href="http://en.wikipedia.org/wiki/Method_(computer_programming)">instance methods</a>.</p>

<p>(The word <code>prototype</code> refers to the <em>prototypical inheritance</em> that JavaScript objects use. You can <a href="https://developer.mozilla.org/en-US/docs/JavaScript/Guide/Details_of_the_Object_Model">read more on the JavaScript object model</a> if you&rsquo;re curious, but don&rsquo;t forget to come back!)</p>

<p><code>Array.prototype.slice</code> is the <code>slice</code> function we are looking for. But it&rsquo;s a function that expects to be called in the context of its containing object, e.g. <code>foos.slice(1)</code>, so calling <code>Array.prototype.slice()</code> will never work, no matter what arguments we use.</p>

<p><code>call</code> allows us to call a function and specify the context of that function dynamically. So in effect, what we are saying here is <em>take the <code>slice</code> function, but pretend it&rsquo;s being called on the <code>arguments</code> object, e.g. <code>arguments.slice(1)</code></em>.</p>
<div class="highlight"><pre><code class="javascript language-javascript" data-lang="javascript"><span class="c1">// evented.js</span>
<span class="kd">var</span> <span class="nx">Evented</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">Event</span><span class="o">:</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="nx">trigger</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">tail</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">slice</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">arguments</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
          <span class="nx">callbacks</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">events</span><span class="p">[</span><span class="nx">event</span><span class="p">];</span>
      <span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">l</span> <span class="o">=</span> <span class="nx">callbacks</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">l</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">callbacks</span><span class="p">[</span><span class="nx">i</span><span class="p">](</span><span class="nx">tail</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">};</span>
</code></pre></div><div class="highlight"><pre><code class="text language-text" data-lang="text">..F

Failures:

  1) Evented Event executes callback with correct arguments when event is triggered
   Message:
     Expected spy unknown to have been called with [ 1, 2 ] but actual calls were [ [ 1, 2 ] ]

Finished in 0.012 seconds
</code></pre></div>
<p>Our test is still failing, but we&rsquo;re getting closer. The problem here is subtle. We wanted to pass <code>1</code> and <code>2</code>, but we&rsquo;re actually passing the array that was returned from the <code>slice</code> function. To convert that array into function arguments, we can use <code>apply</code>.</p>
<div class="highlight"><pre><code class="javascript language-javascript" data-lang="javascript"><span class="c1">// evented.js</span>
<span class="kd">var</span> <span class="nx">Evented</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">Event</span><span class="o">:</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="nx">trigger</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">tail</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">slice</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">arguments</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
          <span class="nx">callbacks</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">events</span><span class="p">[</span><span class="nx">event</span><span class="p">];</span>
      <span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">l</span> <span class="o">=</span> <span class="nx">callbacks</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">l</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">callbacks</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">tail</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">};</span>
</code></pre></div>
<p><code>apply</code> does a very similar job to <code>call</code>. They will both call a function in the context of our choosing, but whereas <code>call</code> will simply pass along its remaining arguments, <code>apply</code> will go one step further and convert an array into function arguments for us.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">...

Finished in 0.008 seconds
3 tests, 3 assertions, 0 failures
</code></pre></div>
<p>Okay, great. Let&rsquo;s take a step back for a minute though, because we kind of glossed over something important there. When we used <code>call</code>, we stated that the <code>slice</code> function should be called in the <em>context</em> of the <code>arguments</code> object. So both of the following examples would be functionally equivalent, if the second one was actually allowed.</p>
<div class="highlight"><pre><code class="javascript language-javascript" data-lang="javascript"><span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">slice</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">arguments</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="nx">arguments</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</code></pre></div>
<p>But when we used <code>apply</code>, we simply passed <code>this</code> as the function context. The <code>this</code> keyword in JavaScript refers to the current execution context or <em>scope</em>. In our usage above, <code>this</code> refers to <code>Evented.Event</code>: the object that holds the <code>trigger</code> function. So any functions that are called when an event is triggered will have access to this object through <code>this</code>.</p>
<div class="highlight"><pre><code class="javascript language-javascript" data-lang="javascript"><span class="nx">eventObj</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
<span class="p">});</span>

<span class="nx">eventObj</span><span class="p">.</span><span class="nx">trigger</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">);</span>
  <span class="c1">// =&gt; logs the Evented.Event object</span>
</code></pre></div>
<p>We know that we can use <code>apply</code> to dynamically alter <code>this</code>, so why don&rsquo;t we take full advantage of that and add this functionality to our event system? Let&rsquo;s specify the desired behaviour first and then write it.</p>
<div class="highlight"><pre><code class="javascript language-javascript" data-lang="javascript"><span class="c1">// evented-spec.js</span>
<span class="nx">describe</span><span class="p">(</span><span class="s1">&#39;Event&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// ...</span>
  <span class="nx">it</span><span class="p">(</span><span class="s1">&#39;executes callback in context of another object&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{};</span>
      <span class="nx">eventObj</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">expect</span><span class="p">(</span><span class="k">this</span><span class="p">).</span><span class="nx">toBe</span><span class="p">(</span><span class="nx">obj</span><span class="p">);</span>
      <span class="p">},</span> <span class="nx">obj</span><span class="p">);</span>
      <span class="nx">eventObj</span><span class="p">.</span><span class="nx">trigger</span><span class="p">(</span><span class="s1">&#39;bar&#39;</span><span class="p">);</span>
    <span class="p">});</span>
<span class="p">});</span>
</code></pre></div><div class="highlight"><pre><code class="text language-text" data-lang="text">...F

Failures:

  1) Evented Event executes callback in context of another object
   Message:
     Expected { on: Function ... } to be { }.

Finished in 0.017 seconds
4 tests, 4 assertions, 1 failure
</code></pre></div>
<p>Notice that we want to pass a context object of our choice as the third argument to <code>on</code>. Now let&rsquo;s make that work. We&rsquo;ll keep track of things by storing the callback function and the context together in an array and store that array in <code>this.events</code> as before.</p>
<div class="highlight"><pre><code class="javascript language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">Evented</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">Event</span><span class="o">:</span> <span class="p">{</span>
    <span class="nx">on</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">event</span><span class="p">,</span> <span class="nx">callback</span><span class="p">,</span> <span class="nx">context</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="s1">&#39;events&#39;</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">events</span> <span class="o">=</span> <span class="p">{});</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">events</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">events</span><span class="p">[</span><span class="nx">event</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]);</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">events</span><span class="p">[</span><span class="nx">event</span><span class="p">].</span><span class="nx">push</span><span class="p">([</span><span class="nx">callback</span><span class="p">,</span> <span class="nx">context</span><span class="p">]);</span>
    <span class="p">},</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>
<span class="p">};</span>
</code></pre></div>
<p>In <code>trigger</code>, we still call <code>apply</code> on the callback function, this time setting the stored object as the context.</p>
<div class="highlight"><pre><code class="javascript language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">Evented</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">Event</span><span class="o">:</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="nx">trigger</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">tail</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">slice</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">arguments</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
          <span class="nx">callbacks</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">events</span><span class="p">[</span><span class="nx">event</span><span class="p">];</span>
      <span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">l</span> <span class="o">=</span> <span class="nx">callbacks</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">l</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">callback</span> <span class="o">=</span> <span class="nx">callbacks</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
            <span class="nx">context</span> <span class="o">=</span> <span class="nx">callbacks</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">===</span> <span class="kc">undefined</span> <span class="o">?</span> <span class="k">this</span> <span class="o">:</span> <span class="nx">callbacks</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span>
        <span class="nx">callback</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">context</span><span class="p">,</span> <span class="nx">tail</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">};</span>
</code></pre></div>
<p>Notice that if the third argument to <code>on</code> is not given, our stored context will be <code>undefined</code>. If this is the case we want to fallback to using <code>this</code> (the <code>Evented.Event</code> object) as the context. We&rsquo;ve set this up using a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_Operator"><em>conditional operation</em></a>. Let&rsquo;s add another slightly different test, to prove that our fallback works.</p>
<div class="highlight"><pre><code class="javascript language-javascript" data-lang="javascript"><span class="c1">// evented-spec.js</span>
<span class="nx">describe</span><span class="p">(</span><span class="s1">&#39;Event&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// ...</span>
  <span class="nx">it</span><span class="p">(</span><span class="s1">&#39;executes callback in context of containing object&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">eventObj</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">&#39;baz&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
      <span class="nx">expect</span><span class="p">(</span><span class="k">this</span><span class="p">).</span><span class="nx">toBe</span><span class="p">(</span><span class="nx">eventObj</span><span class="p">);</span>
    <span class="p">});</span>
    <span class="nx">eventObj</span><span class="p">.</span><span class="nx">trigger</span><span class="p">(</span><span class="s1">&#39;baz&#39;</span><span class="p">);</span>
  <span class="p">});</span>
<span class="p">});</span>
</code></pre></div><div class="highlight"><pre><code class="text language-text" data-lang="text">.....

Finished in 0.011 seconds
5 tests, 5 assertions, 0 failures
</code></pre></div>
<p>Great! So we have an object that&rsquo;s capable of both announcing and listening for events. It&rsquo;s even capable of changing the scope of <code>this</code> inside callback functions. But it&rsquo;s only one object. If we stopped here, we&rsquo;d have to route all of the events in our program through it; that&rsquo;s a lot of responsibility for one little object. So we need a way of adding this object&rsquo;s functionality to any other object.</p>

<p>Other programming languages, such as Ruby or Python, allow us to define modules; containers for groups of methods and statements. We can use these modules to extend the functionality of other objects. Modules, used in this context, are often referred to as <em>mixins</em>. JavaScript provides no such thing, so let&rsquo;s write a function that can take our <code>Evented.Event</code> object and mix its properties into any other object. We&rsquo;ll call the function <code>extend</code>.</p>
<div class="highlight"><pre><code class="javascript language-javascript" data-lang="javascript"><span class="c1">// evented-spec.js</span>
<span class="nx">describe</span><span class="p">(</span><span class="s1">&#39;Evented&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// ...</span>
  <span class="nx">describe</span><span class="p">(</span><span class="s1">&#39;extend&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">it</span><span class="p">(</span><span class="s1">&#39;copies the properties of Event onto another object&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">newObj</span> <span class="o">=</span> <span class="p">{};</span>
      <span class="nx">Evented</span><span class="p">.</span><span class="nx">extend</span><span class="p">(</span><span class="nx">newObj</span><span class="p">);</span>
      <span class="nx">expect</span><span class="p">(</span><span class="nx">newObj</span><span class="p">.</span><span class="nx">on</span><span class="p">).</span><span class="nx">toEqual</span><span class="p">(</span><span class="nx">Evented</span><span class="p">.</span><span class="nx">Event</span><span class="p">.</span><span class="nx">on</span><span class="p">);</span>
      <span class="nx">expect</span><span class="p">(</span><span class="nx">newObj</span><span class="p">.</span><span class="nx">trigger</span><span class="p">).</span><span class="nx">toEqual</span><span class="p">(</span><span class="nx">Evented</span><span class="p">.</span><span class="nx">Event</span><span class="p">.</span><span class="nx">trigger</span><span class="p">);</span>
    <span class="p">});</span>
  <span class="p">});</span>
<span class="p">});</span>
</code></pre></div><div class="highlight"><pre><code class="text language-text" data-lang="text">.....F

Failures:

  1) Evented extend copies the properties of Event onto another object
   Message:
     TypeError: Object #&lt;Object&gt; has no method &#39;extend&#39;

Finished in 0.012 seconds
6 tests, 6 assertions, 1 failure
</code></pre></div>
<p>We&rsquo;ve asserted that after passing an object to <code>extend</code>, that object should then be the proud owner of two new functions, <code>on</code> and <code>trigger</code>. So we need to iterate through the properties of <code>Evented.Event</code> and copy each property in turn onto the other object.</p>
<div class="highlight"><pre><code class="javascript language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">Evented</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">Event</span><span class="o">:</span> <span class="p">{</span>
    <span class="c1">// ...</span>
  <span class="p">},</span>
  <span class="nx">extend</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">property</span> <span class="k">in</span> <span class="k">this</span><span class="p">.</span><span class="nx">Event</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">other</span><span class="p">[</span><span class="nx">property</span><span class="p">]</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">Event</span><span class="p">[</span><span class="nx">property</span><span class="p">];</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">};</span>
</code></pre></div>
<p>We&rsquo;ve used a <code>for-in</code> loop, which allows us to iterate over the properties of an object. <code>for-in</code> loops iterate over all properties of an object, including those in the <code>prototype</code>, so there can sometimes be <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in#Example">unintended consequences</a> when using this kind of loop. However, since we control the <code>Evented.Event</code> object, we can be confident that we aren&rsquo;t copying unexpected properties onto the other object.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">......

Finished in 0.008 seconds
6 tests, 7 assertions, 0 failures
</code></pre></div>
<p>We can make an improvement to this function. We should consider the return value. At present, there is no <code>return</code> statement, so our function will return <code>undefined</code>. That&rsquo;s not very helpful to our users. Returning the extended object would make the following obvious usage possible.</p>
<div class="highlight"><pre><code class="javascript language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nx">Evented</span><span class="p">.</span><span class="nx">extend</span><span class="p">({});</span>
</code></pre></div>
<p>So let&rsquo;s write one last test.</p>
<div class="highlight"><pre><code class="javascript language-javascript" data-lang="javascript"><span class="c1">// evented-spec.js</span>
<span class="nx">describe</span><span class="p">(</span><span class="s1">&#39;Evented&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">describe</span><span class="p">(</span><span class="s1">&#39;extend&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="nx">it</span><span class="p">(</span><span class="s1">&#39;returns the extended object&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">{};</span>
      <span class="nx">expect</span><span class="p">(</span><span class="nx">Evented</span><span class="p">.</span><span class="nx">extend</span><span class="p">(</span><span class="nx">a</span><span class="p">)).</span><span class="nx">toBe</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span>
    <span class="p">});</span>
  <span class="p">});</span>
<span class="p">});</span>
</code></pre></div><div class="highlight"><pre><code class="text language-text" data-lang="text">......F

Failures:

  1) Evented extend returns the extended object
   Message:
     Expected undefined to be { on : Function, ... }.

Finished in 0.012 seconds
7 tests, 8 assertions, 1 failure
</code></pre></div>
<p>And if we return the object&hellip;</p>
<div class="highlight"><pre><code class="javascript language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">Evented</span> <span class="o">=</span> <span class="p">{</span>
  <span class="c1">// ...</span>
  <span class="nx">extend</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">property</span> <span class="k">in</span> <span class="k">this</span><span class="p">.</span><span class="nx">Event</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">other</span><span class="p">[</span><span class="nx">property</span><span class="p">]</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">Event</span><span class="p">[</span><span class="nx">property</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">other</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>
</code></pre></div><div class="highlight"><pre><code class="text language-text" data-lang="text">.......

Finished in 0.01 seconds
7 tests, 8 assertions, 0 failures
</code></pre></div>
<p>So there we have it. In only 24 lines of code and 42 lines of test code, we have a working event system. You can browse <a href="http://github.com/joecorcoran/event-tutorial-complete">the finished code on GitHub</a>.</p>

<h2>Further exploration</h2>

<ul>
<li>Add another function to our <code>Evented.Event</code> object named <code>off</code>. This function should receive one argument, an event name, and should remove all functions bound to that event.</li>
<li>Consider the <a href="http://backbonejs.org/docs/backbone.html#section-13"><code>on</code> and <code>off</code> functions from <code>Backbone.Events</code></a> and how they differ from ours.</li>
<li>Modify our <code>on</code> function such that if the event name given is <code>all</code>, the callback function will be called when <em>any</em> event is triggered. Describe this behaviour by using spies, then write it.</li>
<li>Consider the <a href="http://backbonejs.org/#Events-listenTo"><code>listenTo</code> and <code>stopListening</code> functions from <code>Backbone.Events</code></a> and how they differ from <code>on</code> and <code>off</code>.</li>
<li>Look back at the very first tests we wrote. Do they describe our code in a meaningful way? Are we better off with them or without them?</li>
</ul>

      <section class="comments">
        <p>
  <a href="#" id="show_comments">Show comments</a>
</p>
<div id="disqus_thread"></div>
<script type="text/javascript">
var disqus_shortname = 'joecorcoran',
    disqus_title     = 'Building a minimal JavaScript event system',
    showComments     = function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    },
    commentsLink = document.getElementById('show_comments');
commentsLink.onclick = function() {
  showComments();
  commentsLink.style.display = 'none';
  return false;
};
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

      </section>
      <footer>
        <p>
          <a href="/" class="back">Back to index</a>
        </p>
      </footer>
    </article>
    
  </body>
</html>