<!DOCTYPE html>
<html>
  <head>
    <title>A simple pattern for cleaning up your Ruby DSL :: Joe Corcoran</title>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="author" content="Joe Corcoran">
<script type="text/javascript" src="//use.typekit.net/lbi3uvk.js"></script>
<script type="text/javascript">try{Typekit.load();}catch(e){}</script>

<link rel="stylesheet" href="/public/main.min.css" type="text/css" />
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-3245696-4']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
  </head>
  <body>
    <header role="banner" class="banner">
  <div class="banner-content">
    <h1><a href="/">Joe Corcoran</a></h1>
    <nav>
      <ul>
        <li><a href="/" class="active">Blog</a></li>
        <li><a href="/about" >About</a></li>
        <li><a href="/projects" >Projects</a></li>
      </ul>
    </nav>
  </div>
</header>
    <article class="post">
      <header>
        <h1>A simple pattern for cleaning up your Ruby DSL</h1>
        <time datetime="2013-09-04T00:00:00+01:00">04 September 2013</time>
        

  <ul class="tags">
    
      <li>
        <a href="/tags/ruby">ruby</a>
      </li>
    
      <li>
        <a href="/tags/dsl">dsl</a>
      </li>
    
      <li>
        <a href="/tags/delegator+pattern">delegator pattern</a>
      </li>
    
      <li>
        <a href="/tags/builder+pattern">builder pattern</a>
      </li>
    
      <li>
        <a href="/tags/cucumber">cucumber</a>
      </li>
    
  </ul>


      </header>
      <p>I&#39;ve recently been working on a project that involved building a Ruby <a href="http://en.wikipedia.org/wiki/Domain-specific_language">DSL</a>. As an experiment, I decided to use only <a href="http://cukes.info">Cucumber</a> to describe the behaviour of the code and leave the unit tests until later. I quite enjoyed this way of
working at first, as it forced me to maintain focus on the end user experience and worry less about describing the stuff underneath.</p>

<p>A negative side effect of this approach was that without unit tests keeping me in check, things got a little messy. In lieu of a separate class responsible for DSL behaviour, DSL methods ended up sitting alongside non-DSL methods without much indication of their intended use to users or future maintainers. Worse, sometimes the DSL methods would be the only entry point to a particular feature.</p>

<p>The following code demonstrates the problem on a small scale. I&#39;ll leave it up to you to imagine the same situation with four or five times the number of methods.</p>

<p>The main class reponsible for the DSL would look something like this:</p>
<div class="highlight"><pre><code class="ruby"><span class="k">class</span> <span class="nc">Config</span>
  <span class="kp">attr_reader</span> <span class="ss">:file_paths</span>

  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
    <span class="vi">@file_paths</span> <span class="o">=</span> <span class="o">[]</span>
    <span class="nb">self</span><span class="o">.</span><span class="n">instance_eval</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="p">)</span> <span class="k">if</span> <span class="nb">block_given?</span>
  <span class="k">end</span>

  <span class="c1"># DSL method</span>
  <span class="k">def</span> <span class="nf">files</span><span class="p">(</span><span class="o">*</span><span class="n">paths</span><span class="p">)</span>
    <span class="vi">@file_paths</span> <span class="o">+=</span> <span class="n">paths</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="o">|</span><span class="nb">p</span><span class="o">|</span> <span class="no">File</span><span class="o">.</span><span class="n">expand_path</span><span class="p">(</span><span class="nb">p</span><span class="p">)</span> <span class="p">}</span>
  <span class="k">end</span>

  <span class="c1"># non-DSL method</span>
  <span class="k">def</span> <span class="nf">save!</span>
    <span class="vi">@file_paths</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">path</span><span class="o">|</span>
      <span class="no">File</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>
<p>Intended use follows the <a href="http://en.wikipedia.org/wiki/Builder_pattern">builder pattern</a>, with some of that <code>instance_eval</code> magic that you either love or hate:</p>
<div class="highlight"><pre><code class="ruby"><span class="no">Config</span><span class="o">.</span><span class="n">new</span> <span class="k">do</span>
  <span class="n">files</span> <span class="s1">&#39;foo.bar&#39;</span><span class="p">,</span> <span class="s1">&#39;baz/qux.quux&#39;</span>
<span class="k">end</span>
</code></pre></div>
<p>Fine. But we have a problem when a user would rather not use the code in this manner. Ideally, a block-based DSL like this would be an optional nicety and not the sole way of getting things done.</p>

<p>This problem becomes even more obvious when writing unit tests &#8212; we are users of our own code, after all &#8212; and it&#39;s necessary to keep on initializing new objects in various states of configuration by using the DSL block. Not to mention that use of mock objects is made practically impossible in this case thanks to the altered scope from <code>instance_eval</code>.</p>

<p>To fix this, I settled on the following solution.</p>
<div class="highlight"><pre><code class="ruby"><span class="nb">require</span> <span class="s1">&#39;delegate&#39;</span>

<span class="k">class</span> <span class="nc">Config</span>
  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">build</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
    <span class="n">config</span> <span class="o">=</span> <span class="kp">new</span>
    <span class="n">delegator</span> <span class="o">=</span> <span class="no">ConfigDelegator</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">config</span><span class="p">)</span>
    <span class="n">delegator</span><span class="o">.</span><span class="n">instance_eval</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
    <span class="n">config</span>
  <span class="k">end</span>

  <span class="kp">attr_reader</span> <span class="ss">:file_paths</span>

  <span class="k">def</span> <span class="nf">initialize</span>
    <span class="vi">@file_paths</span> <span class="o">=</span> <span class="o">[]</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">add_paths</span><span class="p">(</span><span class="o">*</span><span class="n">paths</span><span class="p">)</span>
    <span class="vi">@file_paths</span> <span class="o">+=</span> <span class="n">paths</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="o">|</span><span class="nb">p</span><span class="o">|</span> <span class="no">File</span><span class="o">.</span><span class="n">expand_path</span><span class="p">(</span><span class="nb">p</span><span class="p">)</span> <span class="p">}</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">save!</span>
    <span class="vi">@file_paths</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">path</span><span class="o">|</span>
      <span class="no">File</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">class</span> <span class="nc">ConfigDelegator</span> <span class="o">&lt;</span> <span class="no">SimpleDelegator</span>
    <span class="k">def</span> <span class="nf">files</span><span class="p">(</span><span class="o">*</span><span class="n">paths</span><span class="p">)</span>
      <span class="n">add_paths</span><span class="p">(</span><span class="o">*</span><span class="n">paths</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div><div class="highlight"><pre><code class="ruby"><span class="no">Config</span><span class="o">.</span><span class="n">build</span> <span class="k">do</span>
  <span class="n">files</span> <span class="s1">&#39;foo.bar&#39;</span><span class="p">,</span> <span class="s1">&#39;baz/qux.quux&#39;</span>
<span class="k">end</span>
</code></pre></div>
<p>I&#39;m sure the idea is nothing new, but it has a number of benefits.</p>

<p>By using a <a href="http://www.ruby-doc.org/stdlib-2.0.0/libdoc/delegate/rdoc/Delegator.html">delegator object</a> we can isolate the DSL methods, making them only available inside the <code>build</code> block. The footprint of the DSL is now clearer, since DSL methods are defined on the delegator class.</p>

<p>Ruby DSL behavior frequently deviates considerably from the concept of simply <a href="http://www.purl.org/stefan_ram/pub/doc_kay_oop_en">constructing objects and passing messages between them</a>. In the interest of providing a simple user experience, we are tempted to write complex behaviour into a DSL method. Separating our concerns presents the opportunity to keep a watchful eye on this complexity as it inevitably grows.</p>

<p>Cleaning up like this also allows for better unit testing. In the example above, the action of adding paths can be isolated without having to touch the DSL at all. What&#39;s more, the user can ignore the DSL completely if they wish.</p>
<div class="highlight"><pre><code class="ruby"><span class="n">config</span> <span class="o">=</span> <span class="no">Config</span><span class="o">.</span><span class="n">new</span>
<span class="n">config</span><span class="o">.</span><span class="n">add_paths</span><span class="p">(</span><span class="s1">&#39;foo.bar&#39;</span><span class="p">,</span> <span class="s1">&#39;baz/qux.quux&#39;</span><span class="p">)</span>
<span class="n">config</span><span class="o">.</span><span class="n">save!</span>
</code></pre></div>
<p>A combination of unit tests for the non-DSL methods and acceptance tests for the DSL methods seems like a good fit to me.</p>

<p>It turns out this behavior is easy to extract into a module for reuse too.</p>
<div class="highlight"><pre><code class="ruby"><span class="nb">require</span> <span class="s1">&#39;delegate&#39;</span>

<span class="k">module</span> <span class="nn">DSL</span>
  <span class="k">def</span> <span class="nf">build</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
    <span class="n">base</span> <span class="o">=</span> <span class="nb">self</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
    <span class="n">delegator_klass</span> <span class="o">=</span> <span class="nb">self</span><span class="o">.</span><span class="n">const_get</span><span class="p">(</span><span class="s1">&#39;DSLDelegator&#39;</span><span class="p">)</span>
    <span class="n">delegator</span> <span class="o">=</span> <span class="n">delegator_klass</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
    <span class="n">delegator</span><span class="o">.</span><span class="n">instance_eval</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
    <span class="n">base</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">dsl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
    <span class="n">delegator_klass</span> <span class="o">=</span> <span class="no">Class</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="no">SimpleDelegator</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
    <span class="nb">self</span><span class="o">.</span><span class="n">const_set</span><span class="p">(</span><span class="s1">&#39;DSLDelegator&#39;</span><span class="p">,</span> <span class="n">delegator_klass</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div><div class="highlight"><pre><code class="ruby"><span class="k">class</span> <span class="nc">Config</span>
  <span class="kp">extend</span> <span class="no">DSL</span>
  <span class="c1"># ...</span>
  <span class="n">dsl</span> <span class="k">do</span>
    <span class="c1"># DSL methods defined here</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>
<p>The delegator class is created when the <code>dsl</code> class method is used. The class is assigned to the constant <code>DSLDelegator</code> and namespaced under the extending class.</p>

<p>My favourite thing about this approach is that it brings added clarity of thought. Simply having a clear place for the DSL methods to live and having them on hand in the same file as the class to which they relate has made iterative development on the project a little quicker and lot more enjoyable.</p>

      <section class="comments">
        <p>
  <a href="#" id="show_comments">Show comments</a>
</p>
<div id="disqus_thread"></div>
<script type="text/javascript">
var disqus_shortname = 'joecorcoran',
    disqus_title     = 'A simple pattern for cleaning up your Ruby DSL',
    showComments     = function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    },
    commentsLink = document.getElementById('show_comments');
commentsLink.onclick = function() {
  showComments();
  commentsLink.style.display = 'none';
  return false;
};
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

      </section>
      <footer>
        <p>
          <a href="/" class="back">Back to index</a>
        </p>
      </footer>
    </article>
    
  </body>
</html>